{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/aria/source/css/atom-one-dark.css","path":"css/atom-one-dark.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/commentjs.css","path":"css/commentjs.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/comment.styl","path":"css/comment.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/atom-one-light.css","path":"css/atom-one-light.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/header.styl","path":"css/header.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/footer.styl","path":"css/footer.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/info.styl","path":"css/info.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/lightgallery.min.css","path":"css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/nav.styl","path":"css/nav.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/page.styl","path":"css/page.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/reward.styl","path":"css/reward.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/sidebar.styl","path":"css/sidebar.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/css/solarized-dark.css","path":"css/solarized-dark.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/solarized-light.css","path":"css/solarized-light.css","modified":0,"renderable":1},{"_id":"themes/aria/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/aria/source/fonts/lg.eot","path":"fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/aria/source/fonts/lg.svg","path":"fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/aria/source/fonts/lg.woff","path":"fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/aria/source/fonts/lg.ttf","path":"fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/aria/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/aria/source/images/background.png","path":"images/background.png","modified":0,"renderable":1},{"_id":"themes/aria/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/aria/source/js/busuanzi.pure.mini.js","path":"js/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/commentjs.js","path":"js/commentjs.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/custom.js","path":"js/custom.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/fontawesome-all.min.js","path":"js/fontawesome-all.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/highlight.min.js","path":"js/highlight.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lg-fullscreen.min.js","path":"js/lg-fullscreen.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lg-hash.min.js","path":"js/lg-hash.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lg-pager.min.js","path":"js/lg-pager.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lg-thumbnail.min.js","path":"js/lg-thumbnail.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lg-zoom.min.js","path":"js/lg-zoom.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/lightgallery.min.js","path":"js/lightgallery.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/marked.min.js","path":"js/marked.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/timeago.min.js","path":"js/timeago.min.js","modified":0,"renderable":1},{"_id":"themes/aria/source/js/util.js","path":"js/util.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Object-Detection.md","hash":"4dfcbb6c08ce07a644b1ed377b97d1ef15e7bfff","modified":1614395061557},{"_id":"source/makefile/index.md","hash":"c90bb5417e27f8acc46b231a54bfbb1641989242","modified":1612195238925},{"_id":"source/_posts/makefile.md","hash":"ceeee1fdfcaf766622fcff8e793f8b71c248775e","modified":1613723302791},{"_id":"source/about/index.md","hash":"de33e15fb5814bb861d728ab956e858d82cd0090","modified":1612108131142},{"_id":"source/tags/index.md","hash":"86a6af23ac51769caa651e1b61006919fd4660c4","modified":1612108136315},{"_id":"themes/aria/.gitignore","hash":"c834fafd18364f84ecdb85f8e7116e0587f38097","modified":1612106028005},{"_id":"themes/aria/README.zh_CN.md","hash":"81d56793468f0a865466a8608cc0b163e8e50038","modified":1612106028008},{"_id":"themes/aria/_config.yml","hash":"eb29fcbe4745c414bb52a59e0bf1b61561ec8a13","modified":1613738981637},{"_id":"themes/aria/README.md","hash":"8b1022cfb84b0d5b4ea35c1804cd4960786253e4","modified":1612106028008},{"_id":"themes/aria/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1612106028008},{"_id":"themes/aria/_config.yml.example","hash":"8adb7a71f8f706ddbc4866b6daf120f4f3f1de42","modified":1612106028008},{"_id":"themes/aria/package.json","hash":"204daa5c8bcb223c75d48f8fe03ae0cf64c09d6e","modified":1612106028008},{"_id":"themes/aria/.github/CODE_OF_CONDUCT.md","hash":"9d4763e6ab7a83a95ac7b71d9231b054613ee80a","modified":1612106028005},{"_id":"themes/aria/languages/default.yml","hash":"4c9276c495c0e83942599d8b3eef358c2f01c719","modified":1612106028008},{"_id":"themes/aria/languages/en.yml","hash":"4c9276c495c0e83942599d8b3eef358c2f01c719","modified":1612106028008},{"_id":"themes/aria/languages/zh_CN.yml","hash":"3b54b6c97901b050dbeb9196810af2306cd5dcc9","modified":1612106028008},{"_id":"themes/aria/languages/zh_HK.yml","hash":"3ef62cac353a5ffc390897720215525380521738","modified":1612106028008},{"_id":"themes/aria/languages/zh_TW.yml","hash":"3ef62cac353a5ffc390897720215525380521738","modified":1612106028008},{"_id":"themes/aria/layout/.header.njk.kate-swp","hash":"455009eba9f44320110c652a1188cdb6aa02ed15","modified":1612190702297},{"_id":"themes/aria/layout/_layout.njk","hash":"79f050626701f8dfaff0442f2328a5360a5d9064","modified":1612106028008},{"_id":"themes/aria/layout/archive.njk","hash":"00969950276c7f2ec5e44f0e2348d2ce075999b6","modified":1612106028008},{"_id":"themes/aria/layout/categories.njk","hash":"2b25faba94c55a036a10e6bc68cf9633cbe5713d","modified":1612106028008},{"_id":"themes/aria/layout/category.njk","hash":"44471c4909635c31f2dcddaafe052b1c65d7ae7c","modified":1612106028008},{"_id":"themes/aria/layout/comment.njk","hash":"d49bf954b953d75fe510e9e39615836c6fe05579","modified":1612106028008},{"_id":"themes/aria/layout/footer.njk","hash":"5bdc8d7a407ac721d0869302cec6e4a7ceefce12","modified":1612106028008},{"_id":"themes/aria/.github/CONTRIBUTING.md","hash":"79440006745ae233729ceccae96fcc9b654f3100","modified":1612106028005},{"_id":"themes/aria/layout/header.njk","hash":"f42426b3bff2967e90977666b6b167f5151dbb0d","modified":1612190700177},{"_id":"themes/aria/layout/info.njk","hash":"e540fd8e31569cf776a129f6fd4a40ef4db2ea1a","modified":1612106028008},{"_id":"themes/aria/layout/page.njk","hash":"adcfd3830e6433f8613d22f879fc194d6ef973b9","modified":1612106028008},{"_id":"themes/aria/layout/index.njk","hash":"94ff769d7e3abcfccc423fee3bcb35b77c1ff801","modified":1612106028008},{"_id":"themes/aria/layout/reward.njk","hash":"47081449f1f55f84b89765c0a859e562d7a9602a","modified":1612106028008},{"_id":"themes/aria/layout/post.njk","hash":"45b6a4115ce64fc49e3b4f0bc71dad9bf0e2fa67","modified":1612106028008},{"_id":"themes/aria/layout/sidebar.njk","hash":"68f05c56f426e86300c3420e4be9536ac43fcc3c","modified":1612106028008},{"_id":"themes/aria/layout/tag.njk","hash":"970aa4e001b617e95734a676b6d55bbf9842cb55","modified":1612106028008},{"_id":"themes/aria/layout/tags.njk","hash":"b2a9278ddd5d41ddd01b589e662065b1ac351ae4","modified":1612106028008},{"_id":"themes/aria/source/css/custom.styl","hash":"957c0ec7bbbd66daac71d5ecbf4407ba598e8b2f","modified":1612106028012},{"_id":"themes/aria/scripts/regexp-tags.js","hash":"203cbd4e867888ac365580c6bf6f88719926916c","modified":1612106028012},{"_id":"themes/aria/source/css/comment.styl","hash":"9820017c06ddcb86fac84d3fd4823d60316dbd4e","modified":1612106028012},{"_id":"themes/aria/.github/ISSUE_TEMPLATE.md","hash":"7043b0a86411108976120fb19e45d8c141cd4b00","modified":1612106028005},{"_id":"themes/aria/source/css/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1612106028012},{"_id":"themes/aria/source/css/header.styl","hash":"9d467bb58fc2390c93ce9f5b4f95c6995bc0764e","modified":1612106028012},{"_id":"themes/aria/source/css/footer.styl","hash":"67c846abd8b220a9586399a0a8e773bce2cfb515","modified":1612106028012},{"_id":"themes/aria/source/css/info.styl","hash":"8c500a1d2f1897d8f8319119cb1572f7ba8acca6","modified":1612106028012},{"_id":"themes/aria/source/css/index.styl","hash":"eda66df68494d24fb0cfcc433df1c528c5e86f7a","modified":1612106028012},{"_id":"themes/aria/source/css/lightgallery.min.css","hash":"9e76bdad163856774a96b1230a08dc506600a973","modified":1612106028012},{"_id":"themes/aria/source/css/nav.styl","hash":"28ecd2976d4a2051e8c5d0e7c0054180e560f7c5","modified":1612106028012},{"_id":"themes/aria/source/css/main.styl","hash":"871b1f4a96f009dffd0c37f143b702d7432678df","modified":1612106028012},{"_id":"themes/aria/source/css/normalize.css","hash":"734a72e6c28d4a3a870404fb4abf72723c754296","modified":1612106028012},{"_id":"themes/aria/source/css/reward.styl","hash":"d6d79ff8ed2a5e920f7812328035fccfbdffa3a7","modified":1612106028012},{"_id":"themes/aria/source/css/post.styl","hash":"93df40f83d77ba50e792513443f584b16a8c0eb0","modified":1612106028012},{"_id":"themes/aria/source/css/page.styl","hash":"68866f596c9ee6dac1c28b4d67bfab2cc8c9c306","modified":1612106028012},{"_id":"themes/aria/source/css/sidebar.styl","hash":"990d3513b566f7a66513c1c5c8c2b020ac1691a9","modified":1612190222465},{"_id":"themes/aria/.github/PULL_REQUEST_TEMPLATE.md","hash":"6b606f25f81eac248bdacb64cd6a767856e1629f","modified":1612106028005},{"_id":"themes/aria/source/css/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1612106028012},{"_id":"themes/aria/source/css/variables.styl","hash":"2e1fd80981ca443ca0bc5c6747fddd006e5b9228","modified":1612192927332},{"_id":"themes/aria/source/css/commentjs.css","hash":"d00731f87a5946fe70c893ba52ccc2b29c1f7ae6","modified":1612106028012},{"_id":"themes/aria/source/css/atom-one-light.css","hash":"13e7620fe2842fa91cb309391a0b01a0c8712f12","modified":1612106028012},{"_id":"themes/aria/source/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1612106028012},{"_id":"themes/aria/source/css/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1612106028012},{"_id":"themes/aria/source/images/avatar.png","hash":"e63be2fab169a0478af27c47240d1d123fa2b2ba","modified":1612106028012},{"_id":"themes/aria/source/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1612106028012},{"_id":"themes/aria/source/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1612106028015},{"_id":"themes/aria/source/js/clipboard.min.js","hash":"ee60ca5ba9401456105ef703a98092369b579c80","modified":1612106028015},{"_id":"themes/aria/source/js/custom.js","hash":"7e3e36b3ba8de9c168fa50d4b77449d9865b011a","modified":1612106028015},{"_id":"themes/aria/source/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1612106028012},{"_id":"themes/aria/source/js/index.js","hash":"261b09f67d7ed011a4a1f5bb1342a5d203a2a89f","modified":1612106028022},{"_id":"themes/aria/source/fonts/lg.svg","hash":"50a2216596766a48655e3f87e1d1000ba93bf8a1","modified":1612106028012},{"_id":"themes/aria/source/js/lg-fullscreen.min.js","hash":"71cf4fbc9ebbc7ccf1c580cd0389f0a28df64bd6","modified":1612106028022},{"_id":"themes/aria/source/js/lg-hash.min.js","hash":"163a3eb6bdd227549bb7b5be61dffed36af474fa","modified":1612106028022},{"_id":"themes/aria/source/js/lg-pager.min.js","hash":"c4f5c7d91c87761f1626ebb411e5ed6d456799f0","modified":1612106028022},{"_id":"themes/aria/source/js/lg-zoom.min.js","hash":"b26f6070ad290f937c49289bd52014677dd6073c","modified":1612106028022},{"_id":"themes/aria/source/js/lg-thumbnail.min.js","hash":"3f3024b3ff6a5266bd40ed890398d7f2393cd5a5","modified":1612106028022},{"_id":"themes/aria/source/images/logo.png","hash":"fa35ee718a416900fd4b401300fa995a86c234ad","modified":1612106028015},{"_id":"themes/aria/source/js/lightgallery.min.js","hash":"c2101bab37ebcb47cc21a3b92611493a165e5a79","modified":1612106028022},{"_id":"themes/aria/source/js/scrollspy.js","hash":"724f9a0e12bd5c6a9d8cbf299ef4255621433cbf","modified":1612106028022},{"_id":"themes/aria/source/js/search.js","hash":"9ac9f869aa245a33f1bd72ea58c8168a2f0e9824","modified":1612106028022},{"_id":"themes/aria/source/js/commentjs.js","hash":"c60e44a9aa66628bfcc0912ee3a10469b3c2899b","modified":1612106028015},{"_id":"themes/aria/source/js/util.js","hash":"f4d0034baaf346b532d1a1602c0b48963a018f23","modified":1612106028022},{"_id":"themes/aria/source/js/highlight.min.js","hash":"02bb4cdaf43c85b7ee4ef6ccf1f3fe8e82fd3ceb","modified":1612106028022},{"_id":"themes/aria/source/js/marked.min.js","hash":"c9eb834a28665addef7e66ee1a787fa1cbbb43eb","modified":1612106028022},{"_id":"themes/aria/source/js/timeago.min.js","hash":"d220fcc47be00effec6b5181b97cc0929d10031e","modified":1612106028022},{"_id":"themes/aria/source/js/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1612106028022},{"_id":"themes/aria/source/images/background.png","hash":"c34366140a0250afbd73d62abdc58b1e00e10355","modified":1612106028012},{"_id":"themes/aria/ARIA.png","hash":"4d9349d81236b2ad3384d92b5af789aafe71926e","modified":1612106028008},{"_id":"themes/aria/source/js/fontawesome-all.min.js","hash":"d7ff2806086f5924e06910e90a79b44492b52450","modified":1612106028022},{"_id":"public/about/index.html","hash":"6efba377a87e9ebda15051a9b6dbfe970a5bab49","modified":1614395455079},{"_id":"public/tags/index.html","hash":"f90087bdfdc0bc277c1481bb325e9f7d08ff3fa1","modified":1614395455079},{"_id":"public/archives/index.html","hash":"edcf650e44482e3530b23958e87532f374835a61","modified":1614395455079},{"_id":"public/archives/2020/index.html","hash":"db4896154e99974730d08bdf7b9462cf54bf3055","modified":1614395455079},{"_id":"public/archives/2020/02/index.html","hash":"db4896154e99974730d08bdf7b9462cf54bf3055","modified":1614395455079},{"_id":"public/categories/cs-learn/index.html","hash":"966b7af9e442762a14674caffec5dbc04812ca41","modified":1614395455079},{"_id":"public/categories/ml-learn/index.html","hash":"14f02c49a86b79ba813368cf2ad9c239e37bf932","modified":1614395455079},{"_id":"public/tags/c-c/index.html","hash":"9e0b915defda9c72902fdc1bcd543b6d2890388b","modified":1614395455079},{"_id":"public/tags/ml/index.html","hash":"b878ba7793f125089b3ca2b6f5f64c007fc9d570","modified":1614395455079},{"_id":"public/tags/dl/index.html","hash":"ff9b95f409e9e28d6180a861c43b49caa632c2d3","modified":1614395455079},{"_id":"public/tags/object-detection/index.html","hash":"abe9fdea5677d5dcab10f828b14d689b228f79a8","modified":1614395455079},{"_id":"public/makefile/index.html","hash":"93e175c9f2b25bb8e8eefe2b55d6e339e10ded0b","modified":1614395455079},{"_id":"public/2020/02/18/Object-Detection/index.html","hash":"d895464577544bff50d87375d8f76f170e565b2a","modified":1614395455079},{"_id":"public/2020/02/01/makefile/index.html","hash":"70a55db87e2a4423c0e9500a930af1bdb7667bd0","modified":1614395455079},{"_id":"public/index.html","hash":"5b078d702cc3cea50d3938412b33b22b2f9ff502","modified":1614395455079},{"_id":"public/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1613739238985},{"_id":"public/fonts/lg.svg","hash":"50a2216596766a48655e3f87e1d1000ba93bf8a1","modified":1613739238985},{"_id":"public/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1613739238985},{"_id":"public/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1613739238985},{"_id":"public/images/avatar.png","hash":"e63be2fab169a0478af27c47240d1d123fa2b2ba","modified":1613739238985},{"_id":"public/images/logo.png","hash":"fa35ee718a416900fd4b401300fa995a86c234ad","modified":1613739238985},{"_id":"public/css/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1613739238985},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1613739238985},{"_id":"public/css/commentjs.css","hash":"d00731f87a5946fe70c893ba52ccc2b29c1f7ae6","modified":1613739238985},{"_id":"public/css/comment.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1613739238985},{"_id":"public/css/atom-one-light.css","hash":"13e7620fe2842fa91cb309391a0b01a0c8712f12","modified":1613739238985},{"_id":"public/css/header.css","hash":"e85e9c85163aa331326dbaaf4be6f96b4a78cf7c","modified":1613739238985},{"_id":"public/css/footer.css","hash":"d8607ae9fa69b6d24f9245153a7cc1b12b38c20b","modified":1613739238985},{"_id":"public/css/main.css","hash":"93ec56ace5345fe33a2472884b558435230d4310","modified":1613739238985},{"_id":"public/css/info.css","hash":"6367db6485e32e42fedaa8f4a511b5e1461e58b9","modified":1613739238985},{"_id":"public/css/nav.css","hash":"0125102a60953f2220ff2cb1a068ee4a1cc1b9d5","modified":1613739238985},{"_id":"public/css/normalize.css","hash":"734a72e6c28d4a3a870404fb4abf72723c754296","modified":1613739238985},{"_id":"public/css/post.css","hash":"029dcc74105d025e757919cde29c1f97ebc14401","modified":1613739238985},{"_id":"public/css/reward.css","hash":"ceddf9d121de2f30a67148fd3b3c49a729976c29","modified":1613739238985},{"_id":"public/css/page.css","hash":"817e53d9594b484c1c94317d931d346ebef75023","modified":1613739238985},{"_id":"public/css/sidebar.css","hash":"5e9b719a7e1d29eee9150ef376615345e7dbea64","modified":1613739238985},{"_id":"public/css/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1613739238985},{"_id":"public/css/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1613739238985},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1613739238985},{"_id":"public/js/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1613739238985},{"_id":"public/js/clipboard.min.js","hash":"ee60ca5ba9401456105ef703a98092369b579c80","modified":1613739238985},{"_id":"public/js/custom.js","hash":"7e3e36b3ba8de9c168fa50d4b77449d9865b011a","modified":1613739238985},{"_id":"public/js/index.js","hash":"261b09f67d7ed011a4a1f5bb1342a5d203a2a89f","modified":1613739238985},{"_id":"public/js/lg-fullscreen.min.js","hash":"71cf4fbc9ebbc7ccf1c580cd0389f0a28df64bd6","modified":1613739238985},{"_id":"public/js/lg-pager.min.js","hash":"c4f5c7d91c87761f1626ebb411e5ed6d456799f0","modified":1613739238985},{"_id":"public/js/lg-hash.min.js","hash":"163a3eb6bdd227549bb7b5be61dffed36af474fa","modified":1613739238985},{"_id":"public/js/lg-thumbnail.min.js","hash":"3f3024b3ff6a5266bd40ed890398d7f2393cd5a5","modified":1613739238985},{"_id":"public/js/lg-zoom.min.js","hash":"b26f6070ad290f937c49289bd52014677dd6073c","modified":1613739238985},{"_id":"public/js/marked.min.js","hash":"c9eb834a28665addef7e66ee1a787fa1cbbb43eb","modified":1613739238985},{"_id":"public/js/scrollspy.js","hash":"724f9a0e12bd5c6a9d8cbf299ef4255621433cbf","modified":1613739238985},{"_id":"public/js/search.js","hash":"9ac9f869aa245a33f1bd72ea58c8168a2f0e9824","modified":1613739238985},{"_id":"public/js/timeago.min.js","hash":"d220fcc47be00effec6b5181b97cc0929d10031e","modified":1613739238985},{"_id":"public/js/util.js","hash":"f4d0034baaf346b532d1a1602c0b48963a018f23","modified":1613739238985},{"_id":"public/css/index.css","hash":"08447cc8ce7db5bfb3c831adecd05765d8d18bb4","modified":1613739238985},{"_id":"public/css/lightgallery.min.css","hash":"9e76bdad163856774a96b1230a08dc506600a973","modified":1613739238985},{"_id":"public/js/commentjs.js","hash":"c60e44a9aa66628bfcc0912ee3a10469b3c2899b","modified":1613739238985},{"_id":"public/js/highlight.min.js","hash":"02bb4cdaf43c85b7ee4ef6ccf1f3fe8e82fd3ceb","modified":1613739238985},{"_id":"public/js/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1613739238985},{"_id":"public/js/lightgallery.min.js","hash":"c2101bab37ebcb47cc21a3b92611493a165e5a79","modified":1613739238985},{"_id":"public/js/fontawesome-all.min.js","hash":"d7ff2806086f5924e06910e90a79b44492b52450","modified":1613739238985},{"_id":"public/images/background.png","hash":"c34366140a0250afbd73d62abdc58b1e00e10355","modified":1613739238985}],"Category":[{"name":"cs-learn","_id":"cklcaoe4d0004xjl83s5251vs"},{"name":"ml-learn","_id":"cklcaoe4h0007xjl8aaj77c6r"}],"Data":[],"Page":[{"title":"about","date":"2021-01-31T15:48:51.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-01-31 23:48:51\n---\n","updated":"2021-01-31T15:48:51.142Z","path":"about/index.html","comments":1,"layout":"page","_id":"cklcaoe440000xjl8htol0dol","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"learn makefile","date":"2020-02-01T15:30:00.000Z","tags":"c/c++","categories":"c/c++","_content":"\n```bash\ng++ -c func1.cpp\ng++ -c func2.cpp\ng++ -c main.cpp \ng++ -o func main.o fun1.o fun2.o\n```\n\n使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求\n\n```text\ng++ -o hello main.cpp function1.cpp function2.cpp\n```\n\n也可以一步到位\n\n为了解决：\n\n1. 减少命令数，直接写成一个文件来进行执行\n2. 避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译\n\n另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件\n\n <target>:<dependencies>\n\n```makefile\n# the 1-ed\nall:\n   g++ -o func main.cpp func1.cpp func2.cpp\nclean:\n   rm -rf *.o func\n```\n\nall和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）\n\n\n\n```makefile\n# the 2-ed\nall: func\nfunc: main.o func1.o func2.o\n      g++ main.o func1.o func2.o -o func\nmain.o: main.cpp\n      g++ -c main.cpp\nfunc1.o: func1.cpp\n      g++ -c func1.cpp\nfunc2.o: func2.cpp\n      g++ -c func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回\n\n在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动\n\n\n\n```makefile\n# the 3-ed\n\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) main.o func1.o func2.o -o func\nmain.o: main.cpp\n      $(cc) $(CFLAGS) main.cpp\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) func1.cpp\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n添加了一些变量，进行简化\n\n\n\n\n\n```makefile\n# the 4-ed\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      rm -rf *.o func\n```\n\n\n\n引入\\$  ^代表所有的依赖， \\$<代表第一个依赖（对于单参数如func1.o的，\\$<和\\$^都可以）， $@代表target\n\n\n\n```makefile\n# the 5-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) # 用于获取路径下指定模式的文件\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE)) # 用于从一个模式的文件更换为另一个模式文件\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func \n```\n\n\n\nwildcard 用于获取路径下指定模式的文件\n\npatsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件\n\nrm处加入@可以避免回显，否则执行clean时也会输出rm命令\n\n可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已\n\n\n\n```makefile\n# the 6-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp)\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE))\nall: func\nfunc: $(OBJS)\n      $(cc) $(OFLAGS) $^ -o $@\n$(OBJS):%.o:$.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func\n```\n\nStatic Pattern Rule\n\ntargets: target-pattern: prereq-patterns\n\n即将本来的单个target替换成一组target，将具有类型模式的都归为一组\n\ntarget-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的\n\n\n\n另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号\n\n使用\n\n```makefile\nobjs = xxx\\\n\tyyy\\\n\tzzz\\\n```\n\n可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加\n","source":"makefile/index.md","raw":"---\ntitle: learn makefile\ndate: 2020/2/1/23:30\ntags: c/c++\ncategories: c/c++\n---\n\n```bash\ng++ -c func1.cpp\ng++ -c func2.cpp\ng++ -c main.cpp \ng++ -o func main.o fun1.o fun2.o\n```\n\n使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求\n\n```text\ng++ -o hello main.cpp function1.cpp function2.cpp\n```\n\n也可以一步到位\n\n为了解决：\n\n1. 减少命令数，直接写成一个文件来进行执行\n2. 避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译\n\n另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件\n\n <target>:<dependencies>\n\n```makefile\n# the 1-ed\nall:\n   g++ -o func main.cpp func1.cpp func2.cpp\nclean:\n   rm -rf *.o func\n```\n\nall和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）\n\n\n\n```makefile\n# the 2-ed\nall: func\nfunc: main.o func1.o func2.o\n      g++ main.o func1.o func2.o -o func\nmain.o: main.cpp\n      g++ -c main.cpp\nfunc1.o: func1.cpp\n      g++ -c func1.cpp\nfunc2.o: func2.cpp\n      g++ -c func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回\n\n在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动\n\n\n\n```makefile\n# the 3-ed\n\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) main.o func1.o func2.o -o func\nmain.o: main.cpp\n      $(cc) $(CFLAGS) main.cpp\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) func1.cpp\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n添加了一些变量，进行简化\n\n\n\n\n\n```makefile\n# the 4-ed\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      rm -rf *.o func\n```\n\n\n\n引入\\$  ^代表所有的依赖， \\$<代表第一个依赖（对于单参数如func1.o的，\\$<和\\$^都可以）， $@代表target\n\n\n\n```makefile\n# the 5-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) # 用于获取路径下指定模式的文件\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE)) # 用于从一个模式的文件更换为另一个模式文件\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func \n```\n\n\n\nwildcard 用于获取路径下指定模式的文件\n\npatsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件\n\nrm处加入@可以避免回显，否则执行clean时也会输出rm命令\n\n可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已\n\n\n\n```makefile\n# the 6-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp)\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE))\nall: func\nfunc: $(OBJS)\n      $(cc) $(OFLAGS) $^ -o $@\n$(OBJS):%.o:$.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func\n```\n\nStatic Pattern Rule\n\ntargets: target-pattern: prereq-patterns\n\n即将本来的单个target替换成一组target，将具有类型模式的都归为一组\n\ntarget-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的\n\n\n\n另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号\n\n使用\n\n```makefile\nobjs = xxx\\\n\tyyy\\\n\tzzz\\\n```\n\n可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加\n","updated":"2021-02-01T16:00:38.925Z","path":"makefile/index.html","comments":1,"layout":"page","_id":"cklcaoe4a0002xjl88cwd2o0l","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ -c func1.cpp<br>g++ -c func2.cpp<br>g++ -c main.cpp <br>g++ -o func main.o fun1.o fun2.o<br></code></pre></td></tr></table></figure>\n<p>使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">g++ -o hello main.cpp function1.cpp function2.cpp<br></code></pre></td></tr></table></figure>\n<p>也可以一步到位</p>\n<p>为了解决：</p>\n<ol>\n<li>减少命令数，直接写成一个文件来进行执行</li>\n<li>避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译</li>\n</ol>\n<p>另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件</p>\n<p> <target>:<dependencies></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 1-ed</span><br><span class=\"hljs-section\">all:</span><br>   g++ -o func main.cpp func1.cpp func2.cpp<br><span class=\"hljs-section\">clean:</span><br>   rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>all和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 2-ed</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      g++ main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      g++ -c main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      g++ -c func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      g++ -c func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回</p>\n<p>在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 3-ed</span><br><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>添加了一些变量，进行简化</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 4-ed</span><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>引入$  ^代表所有的依赖， $&lt;代表第一个依赖（对于单参数如func1.o的，$&lt;和$^都可以）， $@代表target</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 5-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span> <span class=\"hljs-comment\"># 用于获取路径下指定模式的文件</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span> <span class=\"hljs-comment\"># 用于从一个模式的文件更换为另一个模式文件</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func <br></code></pre></td></tr></table></figure>\n<p>wildcard 用于获取路径下指定模式的文件</p>\n<p>patsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件</p>\n<p>rm处加入@可以避免回显，否则执行clean时也会输出rm命令</p>\n<p>可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 6-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: <span class=\"hljs-variable\">$(OBJS)</span></span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-variable\">$(OBJS)</span>:%.o:$.cpp<br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>Static Pattern Rule</p>\n<p>targets: target-pattern: prereq-patterns</p>\n<p>即将本来的单个target替换成一组target，将具有类型模式的都归为一组</p>\n<p>target-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的</p>\n<p>另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号</p>\n<p>使用</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objs = xxx\\<br>\tyyy\\<br>\tzzz\\<br></code></pre></td></tr></table></figure>\n<p>可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ -c func1.cpp<br>g++ -c func2.cpp<br>g++ -c main.cpp <br>g++ -o func main.o fun1.o fun2.o<br></code></pre></td></tr></table></figure>\n<p>使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">g++ -o hello main.cpp function1.cpp function2.cpp<br></code></pre></td></tr></table></figure>\n<p>也可以一步到位</p>\n<p>为了解决：</p>\n<ol>\n<li>减少命令数，直接写成一个文件来进行执行</li>\n<li>避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译</li>\n</ol>\n<p>另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件</p>\n<p> <target>:<dependencies></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 1-ed</span><br><span class=\"hljs-section\">all:</span><br>   g++ -o func main.cpp func1.cpp func2.cpp<br><span class=\"hljs-section\">clean:</span><br>   rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>all和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 2-ed</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      g++ main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      g++ -c main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      g++ -c func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      g++ -c func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回</p>\n<p>在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 3-ed</span><br><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>添加了一些变量，进行简化</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 4-ed</span><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>引入$  ^代表所有的依赖， $&lt;代表第一个依赖（对于单参数如func1.o的，$&lt;和$^都可以）， $@代表target</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 5-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span> <span class=\"hljs-comment\"># 用于获取路径下指定模式的文件</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span> <span class=\"hljs-comment\"># 用于从一个模式的文件更换为另一个模式文件</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func <br></code></pre></td></tr></table></figure>\n<p>wildcard 用于获取路径下指定模式的文件</p>\n<p>patsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件</p>\n<p>rm处加入@可以避免回显，否则执行clean时也会输出rm命令</p>\n<p>可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 6-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: <span class=\"hljs-variable\">$(OBJS)</span></span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-variable\">$(OBJS)</span>:%.o:$.cpp<br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>Static Pattern Rule</p>\n<p>targets: target-pattern: prereq-patterns</p>\n<p>即将本来的单个target替换成一组target，将具有类型模式的都归为一组</p>\n<p>target-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的</p>\n<p>另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号</p>\n<p>使用</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objs = xxx\\<br>\tyyy\\<br>\tzzz\\<br></code></pre></td></tr></table></figure>\n<p>可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加</p>\n"},{"title":"tags","date":"2021-01-31T15:48:56.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-01-31 23:48:56\n---\n","updated":"2021-01-31T15:48:56.315Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cklcaoe4g0006xjl89lfz8kj8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"learn makefile","date":"2020-02-01T15:30:00.000Z","_content":"\n\n```bash\ng++ -c func1.cpp\ng++ -c func2.cpp\ng++ -c main.cpp \ng++ -o func main.o fun1.o fun2.o\n```\n\n\n使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求\n\n<!--more-->\n\n```text\ng++ -o hello main.cpp function1.cpp function2.cpp\n```\n\n也可以一步到位\n\n为了解决：\n\n1. 减少命令数，直接写成一个文件来进行执行\n2. 避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译\n\n另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件\n\n <target>:<dependencies>\n\n```makefile\n# the 1-ed\nall:\n   g++ -o func main.cpp func1.cpp func2.cpp\nclean:\n   rm -rf *.o func\n```\n\nall和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）\n\n\n\n```makefile\n# the 2-ed\nall: func\nfunc: main.o func1.o func2.o\n      g++ main.o func1.o func2.o -o func\nmain.o: main.cpp\n      g++ -c main.cpp\nfunc1.o: func1.cpp\n      g++ -c func1.cpp\nfunc2.o: func2.cpp\n      g++ -c func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回\n\n在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动\n\n\n\n```makefile\n# the 3-ed\n\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) main.o func1.o func2.o -o func\nmain.o: main.cpp\n      $(cc) $(CFLAGS) main.cpp\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) func1.cpp\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n添加了一些变量，进行简化\n\n\n\n\n\n```makefile\n# the 4-ed\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      rm -rf *.o func\n```\n\n\n\n引入\\$  ^代表所有的依赖， \\$<代表第一个依赖（对于单参数如func1.o的，\\$<和\\$^都可以）， $@代表target\n\n\n\n```makefile\n# the 5-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) # 用于获取路径下指定模式的文件\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE)) # 用于从一个模式的文件更换为另一个模式文件\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func \n```\n\n\n\nwildcard 用于获取路径下指定模式的文件\n\npatsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件\n\nrm处加入@可以避免回显，否则执行clean时也会输出rm命令\n\n可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已\n\n\n\n```makefile\n# the 6-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp)\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE))\nall: func\nfunc: $(OBJS)\n      $(cc) $(OFLAGS) $^ -o $@\n$(OBJS):%.o:$.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func\n```\n\nStatic Pattern Rule\n\ntargets: target-pattern: prereq-patterns\n\n即将本来的单个target替换成一组target，将具有类型模式的都归为一组\n\ntarget-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的\n\n\n\n另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号\n\n使用\n\n```makefile\nobjs = xxx\\\n\tyyy\\\n\tzzz\\\n```\n\n可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加\n","source":"_posts/makefile.md","raw":"---\ntitle: learn makefile\ndate: 2020/2/1/23:30\ntags: c/c++\ncategories: cs-learn\n---\n\n\n```bash\ng++ -c func1.cpp\ng++ -c func2.cpp\ng++ -c main.cpp \ng++ -o func main.o fun1.o fun2.o\n```\n\n\n使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求\n\n<!--more-->\n\n```text\ng++ -o hello main.cpp function1.cpp function2.cpp\n```\n\n也可以一步到位\n\n为了解决：\n\n1. 减少命令数，直接写成一个文件来进行执行\n2. 避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译\n\n另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件\n\n <target>:<dependencies>\n\n```makefile\n# the 1-ed\nall:\n   g++ -o func main.cpp func1.cpp func2.cpp\nclean:\n   rm -rf *.o func\n```\n\nall和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）\n\n\n\n```makefile\n# the 2-ed\nall: func\nfunc: main.o func1.o func2.o\n      g++ main.o func1.o func2.o -o func\nmain.o: main.cpp\n      g++ -c main.cpp\nfunc1.o: func1.cpp\n      g++ -c func1.cpp\nfunc2.o: func2.cpp\n      g++ -c func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回\n\n在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动\n\n\n\n```makefile\n# the 3-ed\n\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) main.o func1.o func2.o -o func\nmain.o: main.cpp\n      $(cc) $(CFLAGS) main.cpp\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) func1.cpp\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) func2.cpp\nclean:\n      rm -rf *.o func\n```\n\n添加了一些变量，进行简化\n\n\n\n\n\n```makefile\n# the 4-ed\ncc = g++\nCFLAGS = -c -Wall # -Wall是显示所有的warning\nOFLAGS = -Wall\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      rm -rf *.o func\n```\n\n\n\n引入\\$  ^代表所有的依赖， \\$<代表第一个依赖（对于单参数如func1.o的，\\$<和\\$^都可以）， $@代表target\n\n\n\n```makefile\n# the 5-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) # 用于获取路径下指定模式的文件\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE)) # 用于从一个模式的文件更换为另一个模式文件\nall: func\nfunc: main.o func1.o func2.o\n      $(cc) $(OFLAGS) $^ -o $@\nmain.o: main.cpp\n      $(cc) $(CFLAGS) $<\nfunc1.o: func1.cpp\n      $(cc) $(CFLAGS) $<\nfunc2.o: func2.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func \n```\n\n\n\nwildcard 用于获取路径下指定模式的文件\n\npatsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件\n\nrm处加入@可以避免回显，否则执行clean时也会输出rm命令\n\n可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已\n\n\n\n```makefile\n# the 6-ed\ncc = g++\nCFLAGS = -c -Wall\nOFLAGS = -Wall\nSOURCE_DIR = .\nSOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp)\nOBJS = $(patsubst %.cpp, %.o, $(SOURCE_FILE))\nall: func\nfunc: $(OBJS)\n      $(cc) $(OFLAGS) $^ -o $@\n$(OBJS):%.o:$.cpp\n      $(cc) $(CFLAGS) $<\nclean:\n      @rm -rf *.o func\n```\n\nStatic Pattern Rule\n\ntargets: target-pattern: prereq-patterns\n\n即将本来的单个target替换成一组target，将具有类型模式的都归为一组\n\ntarget-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的\n\n\n\n另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号\n\n使用\n\n```makefile\nobjs = xxx\\\n\tyyy\\\n\tzzz\\\n```\n\n可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加\n","slug":"makefile","published":1,"updated":"2021-02-19T08:28:22.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklcaoe470001xjl8096gcyoe","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ -c func1.cpp<br>g++ -c func2.cpp<br>g++ -c main.cpp <br>g++ -o func main.o fun1.o fun2.o<br></code></pre></td></tr></table></figure>\n<p>使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求</p>\n<a id=\"more\"></a>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">g++ -o hello main.cpp function1.cpp function2.cpp<br></code></pre></td></tr></table></figure>\n<p>也可以一步到位</p>\n<p>为了解决：</p>\n<ol>\n<li>减少命令数，直接写成一个文件来进行执行</li>\n<li>避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译</li>\n</ol>\n<p>另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件</p>\n<p> <target>:<dependencies></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 1-ed</span><br><span class=\"hljs-section\">all:</span><br>   g++ -o func main.cpp func1.cpp func2.cpp<br><span class=\"hljs-section\">clean:</span><br>   rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>all和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 2-ed</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      g++ main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      g++ -c main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      g++ -c func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      g++ -c func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回</p>\n<p>在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 3-ed</span><br><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>添加了一些变量，进行简化</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 4-ed</span><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>引入$  ^代表所有的依赖， $&lt;代表第一个依赖（对于单参数如func1.o的，$&lt;和$^都可以）， $@代表target</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 5-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span> <span class=\"hljs-comment\"># 用于获取路径下指定模式的文件</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span> <span class=\"hljs-comment\"># 用于从一个模式的文件更换为另一个模式文件</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func <br></code></pre></td></tr></table></figure>\n<p>wildcard 用于获取路径下指定模式的文件</p>\n<p>patsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件</p>\n<p>rm处加入@可以避免回显，否则执行clean时也会输出rm命令</p>\n<p>可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 6-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: <span class=\"hljs-variable\">$(OBJS)</span></span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-variable\">$(OBJS)</span>:%.o:$.cpp<br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>Static Pattern Rule</p>\n<p>targets: target-pattern: prereq-patterns</p>\n<p>即将本来的单个target替换成一组target，将具有类型模式的都归为一组</p>\n<p>target-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的</p>\n<p>另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号</p>\n<p>使用</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objs = xxx\\<br>\tyyy\\<br>\tzzz\\<br></code></pre></td></tr></table></figure>\n<p>可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加</p>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">g++ -c func1.cpp<br>g++ -c func2.cpp<br>g++ -c main.cpp <br>g++ -o func main.o fun1.o fun2.o<br></code></pre></td></tr></table></figure>\n<p>使用g++ -c 进行编译为对象文件，使用g++ -o来进行链接，链接时的文件顺序无要求</p>","more":"<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">g++ -o hello main.cpp function1.cpp function2.cpp<br></code></pre></td></tr></table></figure>\n<p>也可以一步到位</p>\n<p>为了解决：</p>\n<ol>\n<li>减少命令数，直接写成一个文件来进行执行</li>\n<li>避免每次修改文件之后都需要重新将所有文件进行编译，让make通过时间戳看文件是否改动过，改动过才需要重新编译</li>\n</ol>\n<p>另外，在clion中，会将所有文件名为makefile及其变体（任意字母转为大小写）都视为makefile文件，但是在执行make的时候还是只会识别makefile和Makefile文件</p>\n<p> <target>:<dependencies></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 1-ed</span><br><span class=\"hljs-section\">all:</span><br>   g++ -o func main.cpp func1.cpp func2.cpp<br><span class=\"hljs-section\">clean:</span><br>   rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>all和clean是一个target，使用make clean和make all就可以激活对应target，分别执行对应的依赖（指令）</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 2-ed</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      g++ main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      g++ -c main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      g++ -c func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      g++ -c func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>执行make时，等价于make all（等价于执行最上面的一条target），此时all的target依赖于func，但是本地没有func，make继续往下找func，func的target依赖于main.o，本地也没有，就找到main.o的target就是main.cpp，存在本地，继续完成该依赖即g++ -c main.cpp，之后一级一级返回</p>\n<p>在第一次执行make时，输出会显示所有文件都被编译了一遍，之后如果修改了某个文件，只会编译有变化的文件，如果没修改执行make，会显示make没有任何改动</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 3-ed</span><br><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> main.o func1.o func2.o -o func<br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> main.cpp<br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func1.cpp<br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> func2.cpp<br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>添加了一些变量，进行简化</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 4-ed</span><br>cc = g++<br>CFLAGS = -c -Wall <span class=\"hljs-comment\"># -Wall是显示所有的warning</span><br>OFLAGS = -Wall<br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>引入$  ^代表所有的依赖， $&lt;代表第一个依赖（对于单参数如func1.o的，$&lt;和$^都可以）， $@代表target</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 5-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span> <span class=\"hljs-comment\"># 用于获取路径下指定模式的文件</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span> <span class=\"hljs-comment\"># 用于从一个模式的文件更换为另一个模式文件</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: main.o func1.o func2.o</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-section\">main.o: main.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func1.o: func1.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">func2.o: func2.cpp</span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func <br></code></pre></td></tr></table></figure>\n<p>wildcard 用于获取路径下指定模式的文件</p>\n<p>patsubst (pattern subsitution)用于从一个模式的文件更换为另一个模式文件</p>\n<p>rm处加入@可以避免回显，否则执行clean时也会输出rm命令</p>\n<p>可以注意到main.o,func1.o,func2.o基本上都是一样的，只是换了一个名字而已</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># the 6-ed</span><br>cc = g++<br>CFLAGS = -c -Wall<br>OFLAGS = -Wall<br>SOURCE_DIR = .<br>SOURCE_FILE = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SOURCE_DIR)</span>/*.cpp)</span><br>OBJS = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.cpp, %.o, <span class=\"hljs-variable\">$(SOURCE_FILE)</span>)</span><br><span class=\"hljs-section\">all: func</span><br><span class=\"hljs-section\">func: <span class=\"hljs-variable\">$(OBJS)</span></span><br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(OFLAGS)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br><span class=\"hljs-variable\">$(OBJS)</span>:%.o:$.cpp<br>      <span class=\"hljs-variable\">$(cc)</span> <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span><br><span class=\"hljs-section\">clean:</span><br>      @rm -rf *.o func<br></code></pre></td></tr></table></figure>\n<p>Static Pattern Rule</p>\n<p>targets: target-pattern: prereq-patterns</p>\n<p>即将本来的单个target替换成一组target，将具有类型模式的都归为一组</p>\n<p>target-paatern即target文件的模式，prereq-patterns即依赖文件的模式，每个文件都是一一对应的</p>\n<p>另外，使用变量的时候，对于单个字母命名的变量不需要使用括号即可引用，但是对于大于1个字母的就都要使用括号</p>\n<p>使用</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objs = xxx\\<br>\tyyy\\<br>\tzzz\\<br></code></pre></td></tr></table></figure>\n<p>可以定义一个类似数组的结构，之后可以使用OBJS+=ppp.o来添加</p>"},{"title":"目标检测总结","date":"2020-02-18T14:41:00.000Z","mathjax":true,"_content":"\n\n\n###  改进主流网络\n\n#### Two-stage\n\nR-CNN：Selective Search\n $\\longrightarrow$ Fast R-CNN： 将所有候选区域都送入CNN转为特征图的步骤改为直接将原图传入CNN后，在得到的特征图上寻找候选框对应的区域    \n​    $\\longrightarrow$  Faster R-CNN:  增加了RPN，用来替代原先的候选框搜索   \n​        $\\longrightarrow$  RFCN：Faster R-CNN中的ROI，用来从不同尺寸的特征图得到统一输出尺寸，由于ROI后的网络不具有平移不变性，且ROI后的层数会影响检测效率，改进的RFCN使用位置敏感得分图来代替感兴趣判断子网络（ROI和感兴趣判断子网络有区别吗？），并利用位置敏感的ROI池化层，直接对池化后结果进行判别。    \n​\t\t$\\longrightarrow$  Mask R-CNN： 在Faster R-CNN中池化的时候都进行了取整操作，会影响语义分割等像素级别任务的精度，Mask R-CNN使用双线性插值填补非整数位置像素。    \n​\t\t$$\\longrightarrow$$ 后处理的改进： NMS/Soft-NMS/Softer-NMS\n\n<!--more-->\n\n#### One-stage\n\nYOLO-v1\n\n   $\\longrightarrow$ SSD：在后几层卷积上对不同尺度上的特征图运用anchor方法进行候选框提取\n\n   $\\longrightarrow$ YOLO-v2：增加了批归一化，高分辨率分类器，直接目标框位置检测，多尺度训练\n\n   ​\t$\\longrightarrow$ YOLO-v3：改进了backbone（v3中的池化基本由卷积实现，引入残差块），结合特征金字塔网络FPN\n\n#### One-stage + Two-stage\n\n   $\\longrightarrow$ RON：将SSD与Faster R-CNN相结合，改进backbone使用了与RPN相似的策略来引导目标对象搜索\n\n   $\\longrightarrow$ RefineDet：融合了RPN，FPN，SSD，（比较复杂，看不懂）\n\n### 小目标检测\n\n#### backbone改进\n\n$\\longrightarrow$ DetNet：基于RestNet-50改进\n\n$\\longrightarrow$ DenseNet：使用了密集块进行层与层的连接\n\n​\t$\\longrightarrow$ STDN：将DenseNet作为特征提取网络，引入尺寸转换层\n\n#### 增加感受野\n\n$\\longrightarrow$ RFB：在Inception的基础上加入膨胀卷积/空洞卷积，增大感受野\n\n$\\longrightarrow$ TridenNet：以ResNet-101作为backbone，加入空洞卷积，通过多分支结构，权重共享和指定尺度过滤训练\n\n#### 特征融合\n\nFPN\n\n$\\longrightarrow$FPN+RPN\n\n$\\longrightarrow$DES：提高低层特征图语义信息与高层特征语义信息\n\n$\\longrightarrow$NAS-FPN：由于FPN是人为设计的，因此可使用强化学习在一个包含所有跨尺度连接的可拓展搜索空间中   选择最优的特征金字塔架构\n\n#### 级联卷积神经网络\n\n$\\longrightarrow$Faster R-CNN：将两个RPN进行级联优化\n\n$\\longrightarrow$Intertive BBox：在检测阶段（应该就是推理阶段）使用级联的网络架构，将前一个检测模型回归得到的边界框初始化为下一个检测模型的边界框，迭代三次\n\n$\\longrightarrow$Integral loss：针对迭代式边界框回归（如Intertive BBox）单一IOU阈值的问题，将Intertive BBox的三次迭代改为三条支路，每条支路使用不同的IOU阈值\n\n$\\longrightarrow$ Cascade R-CNN：该模型基于前一阶段的输出进行训练，与Intertive BBox相比应该就是Intertive BBox在推理时的结构与其一致，Integral Loss使用的是不同重叠度阈值训练得到的。同时Cascade R-CNN也包含了不同IOU阈值的回归网络，用来提高IOU阈值下的正样本比例。\n\n$\\longrightarrow$HRNet：使用高分辨率的子网络作为第一阶段，然后逐渐并行添加较低分辨率的子网络，得到多个阶段的子网络的输出，之后输出又可以重新传到第一阶段的高分辨率特征图，与其进行融合。\n\n#### 模型训练方式\n\n$\\longrightarrow$YOLO-v2：YOLO-v2的输入是416×416，而backbone在ImageNet的预训练模型使用的是224×224,v2就先在416×416的ImageNet上预训练了网络。\n\n$\\longrightarrow$SNIP：图像金子塔的尺寸归一化，使用图像金字塔来处理不同尺寸的数据，bp时只将与预训练模型所基于的训练数据尺寸相对应的ROI的梯度进行回传。\n\n$\\longrightarrow$perceptual GAN：将所有的物体分为大物体和小物体两个子集,通过挖掘不同尺度物体间的结构关联，perceptual GAN 包含两个子网络: 生成网络( 小物体) 和判别网络 ( 大物体) 。生成网络使用深度残差特征生成模型,通过引入低层细粒度的特征将原始较差的特征转换为高分辨的特征; 判别网络包含两个分支:对抗分支和感知分支,对抗分支用来分辨小物体生成的高分辨率特征与真实的大物体特征,感知分支则通过感知损失提升检测率 。\n\n### 多类别物体检测\n\n#### 训练方式优化\n\n$\\longrightarrow$LSDA：LSDA 首先利用分类数据集初始化神经网络,然后再利用检测数据集进行微调,最后将检测数据集训练的参数迁移到没有检测标签的类别上来实现提高目标检测类别数目\n\n$\\longrightarrow$YOLO9000：使用联合训练策略通过使用标记为检测的图像来学习边界框的坐标预测和目标类别的特定信息 ,将检\n测和分类数据集混合用于模型训练。 当网络看到标记为检测的图像时,能够基于完整的 YOLOv2 损失函数进行反向传播;当看到一个分类的图像时,只能够从该架构的分类特定部分反向传播损失 。还使用了WordNet（看不懂）。\n\n$\\longrightarrow$软采样：将ROI 的梯度重设为与正实例重叠的函数,确保不确定的背景区域相对于难样本 ( hard negative) 的权重更小\n\n#### 网络结构改进\n\n$\\longrightarrow$R-FCN-3000：R-FCN中的位置敏感得分对于多类别情况下计算量会急剧增加，因此提出R-FCN-3000，该网络分为两条支路，一条与R-FCN类似，进行大类别检测，另一条用来进行细粒度分类（所有类别），最终将两条支路得到的类别分数相乘，得到最终的分数\n\n$\\longrightarrow$HSJT：HSJT 首先利用目标类别之间的关系,建立新的层次网络模型,进一步提高识别性能;其次将边界框级标记图像和图像级标记图像结合起来进行联合训练 ,提出一种联合训练生成大规模半监督目标检测的方法 。\n\n### 轻量化模型\n\n$\\longrightarrow$MobileNet-v1：将传统卷积分为深度可分离卷积（即一个卷积核只负责对一个特征图进行卷积）+逐点卷积（1×1卷积）\n\n​\t$\\longrightarrow$MobileNet-v2：增加了Linear bottlenecks，去除小维度输出层后的非线性激活层，增加了inverted residual block，对维度先扩增再缩减。\n\n​\t\t$\\longrightarrow$MobileNet-v3：加入互补搜索技术组合（通过NAS进行架构设计），进行网络结构改进\n\n$\\longrightarrow$ShuffleNetv1：\n\n​\t$\\longrightarrow$ShuffleNetc2:\n\n\n\nILSVRC = ImageNet Large Scale Visual Recognition Challenge","source":"_posts/Object-Detection.md","raw":"---\ntitle: 目标检测总结\ndate: 2020/2/18/22:41\ntags: \n- ml\n- dl \n- object-detection\ncategories: \n- ml-learn\nmathjax: true\n---\n\n\n\n###  改进主流网络\n\n#### Two-stage\n\nR-CNN：Selective Search\n $\\longrightarrow$ Fast R-CNN： 将所有候选区域都送入CNN转为特征图的步骤改为直接将原图传入CNN后，在得到的特征图上寻找候选框对应的区域    \n​    $\\longrightarrow$  Faster R-CNN:  增加了RPN，用来替代原先的候选框搜索   \n​        $\\longrightarrow$  RFCN：Faster R-CNN中的ROI，用来从不同尺寸的特征图得到统一输出尺寸，由于ROI后的网络不具有平移不变性，且ROI后的层数会影响检测效率，改进的RFCN使用位置敏感得分图来代替感兴趣判断子网络（ROI和感兴趣判断子网络有区别吗？），并利用位置敏感的ROI池化层，直接对池化后结果进行判别。    \n​\t\t$\\longrightarrow$  Mask R-CNN： 在Faster R-CNN中池化的时候都进行了取整操作，会影响语义分割等像素级别任务的精度，Mask R-CNN使用双线性插值填补非整数位置像素。    \n​\t\t$$\\longrightarrow$$ 后处理的改进： NMS/Soft-NMS/Softer-NMS\n\n<!--more-->\n\n#### One-stage\n\nYOLO-v1\n\n   $\\longrightarrow$ SSD：在后几层卷积上对不同尺度上的特征图运用anchor方法进行候选框提取\n\n   $\\longrightarrow$ YOLO-v2：增加了批归一化，高分辨率分类器，直接目标框位置检测，多尺度训练\n\n   ​\t$\\longrightarrow$ YOLO-v3：改进了backbone（v3中的池化基本由卷积实现，引入残差块），结合特征金字塔网络FPN\n\n#### One-stage + Two-stage\n\n   $\\longrightarrow$ RON：将SSD与Faster R-CNN相结合，改进backbone使用了与RPN相似的策略来引导目标对象搜索\n\n   $\\longrightarrow$ RefineDet：融合了RPN，FPN，SSD，（比较复杂，看不懂）\n\n### 小目标检测\n\n#### backbone改进\n\n$\\longrightarrow$ DetNet：基于RestNet-50改进\n\n$\\longrightarrow$ DenseNet：使用了密集块进行层与层的连接\n\n​\t$\\longrightarrow$ STDN：将DenseNet作为特征提取网络，引入尺寸转换层\n\n#### 增加感受野\n\n$\\longrightarrow$ RFB：在Inception的基础上加入膨胀卷积/空洞卷积，增大感受野\n\n$\\longrightarrow$ TridenNet：以ResNet-101作为backbone，加入空洞卷积，通过多分支结构，权重共享和指定尺度过滤训练\n\n#### 特征融合\n\nFPN\n\n$\\longrightarrow$FPN+RPN\n\n$\\longrightarrow$DES：提高低层特征图语义信息与高层特征语义信息\n\n$\\longrightarrow$NAS-FPN：由于FPN是人为设计的，因此可使用强化学习在一个包含所有跨尺度连接的可拓展搜索空间中   选择最优的特征金字塔架构\n\n#### 级联卷积神经网络\n\n$\\longrightarrow$Faster R-CNN：将两个RPN进行级联优化\n\n$\\longrightarrow$Intertive BBox：在检测阶段（应该就是推理阶段）使用级联的网络架构，将前一个检测模型回归得到的边界框初始化为下一个检测模型的边界框，迭代三次\n\n$\\longrightarrow$Integral loss：针对迭代式边界框回归（如Intertive BBox）单一IOU阈值的问题，将Intertive BBox的三次迭代改为三条支路，每条支路使用不同的IOU阈值\n\n$\\longrightarrow$ Cascade R-CNN：该模型基于前一阶段的输出进行训练，与Intertive BBox相比应该就是Intertive BBox在推理时的结构与其一致，Integral Loss使用的是不同重叠度阈值训练得到的。同时Cascade R-CNN也包含了不同IOU阈值的回归网络，用来提高IOU阈值下的正样本比例。\n\n$\\longrightarrow$HRNet：使用高分辨率的子网络作为第一阶段，然后逐渐并行添加较低分辨率的子网络，得到多个阶段的子网络的输出，之后输出又可以重新传到第一阶段的高分辨率特征图，与其进行融合。\n\n#### 模型训练方式\n\n$\\longrightarrow$YOLO-v2：YOLO-v2的输入是416×416，而backbone在ImageNet的预训练模型使用的是224×224,v2就先在416×416的ImageNet上预训练了网络。\n\n$\\longrightarrow$SNIP：图像金子塔的尺寸归一化，使用图像金字塔来处理不同尺寸的数据，bp时只将与预训练模型所基于的训练数据尺寸相对应的ROI的梯度进行回传。\n\n$\\longrightarrow$perceptual GAN：将所有的物体分为大物体和小物体两个子集,通过挖掘不同尺度物体间的结构关联，perceptual GAN 包含两个子网络: 生成网络( 小物体) 和判别网络 ( 大物体) 。生成网络使用深度残差特征生成模型,通过引入低层细粒度的特征将原始较差的特征转换为高分辨的特征; 判别网络包含两个分支:对抗分支和感知分支,对抗分支用来分辨小物体生成的高分辨率特征与真实的大物体特征,感知分支则通过感知损失提升检测率 。\n\n### 多类别物体检测\n\n#### 训练方式优化\n\n$\\longrightarrow$LSDA：LSDA 首先利用分类数据集初始化神经网络,然后再利用检测数据集进行微调,最后将检测数据集训练的参数迁移到没有检测标签的类别上来实现提高目标检测类别数目\n\n$\\longrightarrow$YOLO9000：使用联合训练策略通过使用标记为检测的图像来学习边界框的坐标预测和目标类别的特定信息 ,将检\n测和分类数据集混合用于模型训练。 当网络看到标记为检测的图像时,能够基于完整的 YOLOv2 损失函数进行反向传播;当看到一个分类的图像时,只能够从该架构的分类特定部分反向传播损失 。还使用了WordNet（看不懂）。\n\n$\\longrightarrow$软采样：将ROI 的梯度重设为与正实例重叠的函数,确保不确定的背景区域相对于难样本 ( hard negative) 的权重更小\n\n#### 网络结构改进\n\n$\\longrightarrow$R-FCN-3000：R-FCN中的位置敏感得分对于多类别情况下计算量会急剧增加，因此提出R-FCN-3000，该网络分为两条支路，一条与R-FCN类似，进行大类别检测，另一条用来进行细粒度分类（所有类别），最终将两条支路得到的类别分数相乘，得到最终的分数\n\n$\\longrightarrow$HSJT：HSJT 首先利用目标类别之间的关系,建立新的层次网络模型,进一步提高识别性能;其次将边界框级标记图像和图像级标记图像结合起来进行联合训练 ,提出一种联合训练生成大规模半监督目标检测的方法 。\n\n### 轻量化模型\n\n$\\longrightarrow$MobileNet-v1：将传统卷积分为深度可分离卷积（即一个卷积核只负责对一个特征图进行卷积）+逐点卷积（1×1卷积）\n\n​\t$\\longrightarrow$MobileNet-v2：增加了Linear bottlenecks，去除小维度输出层后的非线性激活层，增加了inverted residual block，对维度先扩增再缩减。\n\n​\t\t$\\longrightarrow$MobileNet-v3：加入互补搜索技术组合（通过NAS进行架构设计），进行网络结构改进\n\n$\\longrightarrow$ShuffleNetv1：\n\n​\t$\\longrightarrow$ShuffleNetc2:\n\n\n\nILSVRC = ImageNet Large Scale Visual Recognition Challenge","slug":"Object-Detection","published":1,"updated":"2021-02-27T03:04:21.557Z","_id":"cklcaoe4b0003xjl81rd95m4h","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"改进主流网络\">改进主流网络</h3>\n<h4 id=\"two-stage\">Two-stage</h4>\n<p>R-CNN：Selective Search <span class=\"math inline\">\\(\\longrightarrow\\)</span> Fast R-CNN： 将所有候选区域都送入CNN转为特征图的步骤改为直接将原图传入CNN后，在得到的特征图上寻找候选框对应的区域<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> Faster R-CNN: 增加了RPN，用来替代原先的候选框搜索<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> RFCN：Faster R-CNN中的ROI，用来从不同尺寸的特征图得到统一输出尺寸，由于ROI后的网络不具有平移不变性，且ROI后的层数会影响检测效率，改进的RFCN使用位置敏感得分图来代替感兴趣判断子网络（ROI和感兴趣判断子网络有区别吗？），并利用位置敏感的ROI池化层，直接对池化后结果进行判别。<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> Mask R-CNN： 在Faster R-CNN中池化的时候都进行了取整操作，会影响语义分割等像素级别任务的精度，Mask R-CNN使用双线性插值填补非整数位置像素。<br />\n​ <span class=\"math display\">\\[\\longrightarrow\\]</span> 后处理的改进： NMS/Soft-NMS/Softer-NMS</p>\n<a id=\"more\"></a>\n<h4 id=\"one-stage\">One-stage</h4>\n<p>YOLO-v1</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> SSD：在后几层卷积上对不同尺度上的特征图运用anchor方法进行候选框提取</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> YOLO-v2：增加了批归一化，高分辨率分类器，直接目标框位置检测，多尺度训练</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> YOLO-v3：改进了backbone（v3中的池化基本由卷积实现，引入残差块），结合特征金字塔网络FPN</p>\n<h4 id=\"one-stage-two-stage\">One-stage + Two-stage</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RON：将SSD与Faster R-CNN相结合，改进backbone使用了与RPN相似的策略来引导目标对象搜索</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RefineDet：融合了RPN，FPN，SSD，（比较复杂，看不懂）</p>\n<h3 id=\"小目标检测\">小目标检测</h3>\n<h4 id=\"backbone改进\">backbone改进</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> DetNet：基于RestNet-50改进</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> DenseNet：使用了密集块进行层与层的连接</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> STDN：将DenseNet作为特征提取网络，引入尺寸转换层</p>\n<h4 id=\"增加感受野\">增加感受野</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RFB：在Inception的基础上加入膨胀卷积/空洞卷积，增大感受野</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> TridenNet：以ResNet-101作为backbone，加入空洞卷积，通过多分支结构，权重共享和指定尺度过滤训练</p>\n<h4 id=\"特征融合\">特征融合</h4>\n<p>FPN</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>FPN+RPN</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>DES：提高低层特征图语义信息与高层特征语义信息</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>NAS-FPN：由于FPN是人为设计的，因此可使用强化学习在一个包含所有跨尺度连接的可拓展搜索空间中 选择最优的特征金字塔架构</p>\n<h4 id=\"级联卷积神经网络\">级联卷积神经网络</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Faster R-CNN：将两个RPN进行级联优化</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Intertive BBox：在检测阶段（应该就是推理阶段）使用级联的网络架构，将前一个检测模型回归得到的边界框初始化为下一个检测模型的边界框，迭代三次</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Integral loss：针对迭代式边界框回归（如Intertive BBox）单一IOU阈值的问题，将Intertive BBox的三次迭代改为三条支路，每条支路使用不同的IOU阈值</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> Cascade R-CNN：该模型基于前一阶段的输出进行训练，与Intertive BBox相比应该就是Intertive BBox在推理时的结构与其一致，Integral Loss使用的是不同重叠度阈值训练得到的。同时Cascade R-CNN也包含了不同IOU阈值的回归网络，用来提高IOU阈值下的正样本比例。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>HRNet：使用高分辨率的子网络作为第一阶段，然后逐渐并行添加较低分辨率的子网络，得到多个阶段的子网络的输出，之后输出又可以重新传到第一阶段的高分辨率特征图，与其进行融合。</p>\n<h4 id=\"模型训练方式\">模型训练方式</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>YOLO-v2：YOLO-v2的输入是416×416，而backbone在ImageNet的预训练模型使用的是224×224,v2就先在416×416的ImageNet上预训练了网络。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>SNIP：图像金子塔的尺寸归一化，使用图像金字塔来处理不同尺寸的数据，bp时只将与预训练模型所基于的训练数据尺寸相对应的ROI的梯度进行回传。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>perceptual GAN：将所有的物体分为大物体和小物体两个子集,通过挖掘不同尺度物体间的结构关联，perceptual GAN 包含两个子网络: 生成网络( 小物体) 和判别网络 ( 大物体) 。生成网络使用深度残差特征生成模型,通过引入低层细粒度的特征将原始较差的特征转换为高分辨的特征; 判别网络包含两个分支:对抗分支和感知分支,对抗分支用来分辨小物体生成的高分辨率特征与真实的大物体特征,感知分支则通过感知损失提升检测率 。</p>\n<h3 id=\"多类别物体检测\">多类别物体检测</h3>\n<h4 id=\"训练方式优化\">训练方式优化</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>LSDA：LSDA 首先利用分类数据集初始化神经网络,然后再利用检测数据集进行微调,最后将检测数据集训练的参数迁移到没有检测标签的类别上来实现提高目标检测类别数目</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>YOLO9000：使用联合训练策略通过使用标记为检测的图像来学习边界框的坐标预测和目标类别的特定信息 ,将检 测和分类数据集混合用于模型训练。 当网络看到标记为检测的图像时,能够基于完整的 YOLOv2 损失函数进行反向传播;当看到一个分类的图像时,只能够从该架构的分类特定部分反向传播损失 。还使用了WordNet（看不懂）。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>软采样：将ROI 的梯度重设为与正实例重叠的函数,确保不确定的背景区域相对于难样本 ( hard negative) 的权重更小</p>\n<h4 id=\"网络结构改进\">网络结构改进</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>R-FCN-3000：R-FCN中的位置敏感得分对于多类别情况下计算量会急剧增加，因此提出R-FCN-3000，该网络分为两条支路，一条与R-FCN类似，进行大类别检测，另一条用来进行细粒度分类（所有类别），最终将两条支路得到的类别分数相乘，得到最终的分数</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>HSJT：HSJT 首先利用目标类别之间的关系,建立新的层次网络模型,进一步提高识别性能;其次将边界框级标记图像和图像级标记图像结合起来进行联合训练 ,提出一种联合训练生成大规模半监督目标检测的方法 。</p>\n<h3 id=\"轻量化模型\">轻量化模型</h3>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v1：将传统卷积分为深度可分离卷积（即一个卷积核只负责对一个特征图进行卷积）+逐点卷积（1×1卷积）</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v2：增加了Linear bottlenecks，去除小维度输出层后的非线性激活层，增加了inverted residual block，对维度先扩增再缩减。</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v3：加入互补搜索技术组合（通过NAS进行架构设计），进行网络结构改进</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>ShuffleNetv1：</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>ShuffleNetc2:</p>\n<p>ILSVRC = ImageNet Large Scale Visual Recognition Challenge</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"改进主流网络\">改进主流网络</h3>\n<h4 id=\"two-stage\">Two-stage</h4>\n<p>R-CNN：Selective Search <span class=\"math inline\">\\(\\longrightarrow\\)</span> Fast R-CNN： 将所有候选区域都送入CNN转为特征图的步骤改为直接将原图传入CNN后，在得到的特征图上寻找候选框对应的区域<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> Faster R-CNN: 增加了RPN，用来替代原先的候选框搜索<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> RFCN：Faster R-CNN中的ROI，用来从不同尺寸的特征图得到统一输出尺寸，由于ROI后的网络不具有平移不变性，且ROI后的层数会影响检测效率，改进的RFCN使用位置敏感得分图来代替感兴趣判断子网络（ROI和感兴趣判断子网络有区别吗？），并利用位置敏感的ROI池化层，直接对池化后结果进行判别。<br />\n​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> Mask R-CNN： 在Faster R-CNN中池化的时候都进行了取整操作，会影响语义分割等像素级别任务的精度，Mask R-CNN使用双线性插值填补非整数位置像素。<br />\n​ <span class=\"math display\">\\[\\longrightarrow\\]</span> 后处理的改进： NMS/Soft-NMS/Softer-NMS</p>","more":"<h4 id=\"one-stage\">One-stage</h4>\n<p>YOLO-v1</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> SSD：在后几层卷积上对不同尺度上的特征图运用anchor方法进行候选框提取</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> YOLO-v2：增加了批归一化，高分辨率分类器，直接目标框位置检测，多尺度训练</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> YOLO-v3：改进了backbone（v3中的池化基本由卷积实现，引入残差块），结合特征金字塔网络FPN</p>\n<h4 id=\"one-stage-two-stage\">One-stage + Two-stage</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RON：将SSD与Faster R-CNN相结合，改进backbone使用了与RPN相似的策略来引导目标对象搜索</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RefineDet：融合了RPN，FPN，SSD，（比较复杂，看不懂）</p>\n<h3 id=\"小目标检测\">小目标检测</h3>\n<h4 id=\"backbone改进\">backbone改进</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> DetNet：基于RestNet-50改进</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> DenseNet：使用了密集块进行层与层的连接</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span> STDN：将DenseNet作为特征提取网络，引入尺寸转换层</p>\n<h4 id=\"增加感受野\">增加感受野</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> RFB：在Inception的基础上加入膨胀卷积/空洞卷积，增大感受野</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> TridenNet：以ResNet-101作为backbone，加入空洞卷积，通过多分支结构，权重共享和指定尺度过滤训练</p>\n<h4 id=\"特征融合\">特征融合</h4>\n<p>FPN</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>FPN+RPN</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>DES：提高低层特征图语义信息与高层特征语义信息</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>NAS-FPN：由于FPN是人为设计的，因此可使用强化学习在一个包含所有跨尺度连接的可拓展搜索空间中 选择最优的特征金字塔架构</p>\n<h4 id=\"级联卷积神经网络\">级联卷积神经网络</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Faster R-CNN：将两个RPN进行级联优化</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Intertive BBox：在检测阶段（应该就是推理阶段）使用级联的网络架构，将前一个检测模型回归得到的边界框初始化为下一个检测模型的边界框，迭代三次</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>Integral loss：针对迭代式边界框回归（如Intertive BBox）单一IOU阈值的问题，将Intertive BBox的三次迭代改为三条支路，每条支路使用不同的IOU阈值</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span> Cascade R-CNN：该模型基于前一阶段的输出进行训练，与Intertive BBox相比应该就是Intertive BBox在推理时的结构与其一致，Integral Loss使用的是不同重叠度阈值训练得到的。同时Cascade R-CNN也包含了不同IOU阈值的回归网络，用来提高IOU阈值下的正样本比例。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>HRNet：使用高分辨率的子网络作为第一阶段，然后逐渐并行添加较低分辨率的子网络，得到多个阶段的子网络的输出，之后输出又可以重新传到第一阶段的高分辨率特征图，与其进行融合。</p>\n<h4 id=\"模型训练方式\">模型训练方式</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>YOLO-v2：YOLO-v2的输入是416×416，而backbone在ImageNet的预训练模型使用的是224×224,v2就先在416×416的ImageNet上预训练了网络。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>SNIP：图像金子塔的尺寸归一化，使用图像金字塔来处理不同尺寸的数据，bp时只将与预训练模型所基于的训练数据尺寸相对应的ROI的梯度进行回传。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>perceptual GAN：将所有的物体分为大物体和小物体两个子集,通过挖掘不同尺度物体间的结构关联，perceptual GAN 包含两个子网络: 生成网络( 小物体) 和判别网络 ( 大物体) 。生成网络使用深度残差特征生成模型,通过引入低层细粒度的特征将原始较差的特征转换为高分辨的特征; 判别网络包含两个分支:对抗分支和感知分支,对抗分支用来分辨小物体生成的高分辨率特征与真实的大物体特征,感知分支则通过感知损失提升检测率 。</p>\n<h3 id=\"多类别物体检测\">多类别物体检测</h3>\n<h4 id=\"训练方式优化\">训练方式优化</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>LSDA：LSDA 首先利用分类数据集初始化神经网络,然后再利用检测数据集进行微调,最后将检测数据集训练的参数迁移到没有检测标签的类别上来实现提高目标检测类别数目</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>YOLO9000：使用联合训练策略通过使用标记为检测的图像来学习边界框的坐标预测和目标类别的特定信息 ,将检 测和分类数据集混合用于模型训练。 当网络看到标记为检测的图像时,能够基于完整的 YOLOv2 损失函数进行反向传播;当看到一个分类的图像时,只能够从该架构的分类特定部分反向传播损失 。还使用了WordNet（看不懂）。</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>软采样：将ROI 的梯度重设为与正实例重叠的函数,确保不确定的背景区域相对于难样本 ( hard negative) 的权重更小</p>\n<h4 id=\"网络结构改进\">网络结构改进</h4>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>R-FCN-3000：R-FCN中的位置敏感得分对于多类别情况下计算量会急剧增加，因此提出R-FCN-3000，该网络分为两条支路，一条与R-FCN类似，进行大类别检测，另一条用来进行细粒度分类（所有类别），最终将两条支路得到的类别分数相乘，得到最终的分数</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>HSJT：HSJT 首先利用目标类别之间的关系,建立新的层次网络模型,进一步提高识别性能;其次将边界框级标记图像和图像级标记图像结合起来进行联合训练 ,提出一种联合训练生成大规模半监督目标检测的方法 。</p>\n<h3 id=\"轻量化模型\">轻量化模型</h3>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v1：将传统卷积分为深度可分离卷积（即一个卷积核只负责对一个特征图进行卷积）+逐点卷积（1×1卷积）</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v2：增加了Linear bottlenecks，去除小维度输出层后的非线性激活层，增加了inverted residual block，对维度先扩增再缩减。</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>MobileNet-v3：加入互补搜索技术组合（通过NAS进行架构设计），进行网络结构改进</p>\n<p><span class=\"math inline\">\\(\\longrightarrow\\)</span>ShuffleNetv1：</p>\n<p>​ <span class=\"math inline\">\\(\\longrightarrow\\)</span>ShuffleNetc2:</p>\n<p>ILSVRC = ImageNet Large Scale Visual Recognition Challenge</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cklcaoe470001xjl8096gcyoe","category_id":"cklcaoe4d0004xjl83s5251vs","_id":"cklcaoe4j000axjl84loa6g5r"},{"post_id":"cklcaoe4b0003xjl81rd95m4h","category_id":"cklcaoe4h0007xjl8aaj77c6r","_id":"cklcaoe4j000cxjl8huhpguw1"}],"PostTag":[{"post_id":"cklcaoe470001xjl8096gcyoe","tag_id":"cklcaoe4f0005xjl82ndj7wcc","_id":"cklcaoe4i0009xjl8flrqblqz"},{"post_id":"cklcaoe4b0003xjl81rd95m4h","tag_id":"cklcaoe4i0008xjl84p2z156s","_id":"cklcaoe4k000exjl83i1vclg7"},{"post_id":"cklcaoe4b0003xjl81rd95m4h","tag_id":"cklcaoe4j000bxjl8cdu2h5l3","_id":"cklcaoe4k000fxjl8b9jjc6bm"},{"post_id":"cklcaoe4b0003xjl81rd95m4h","tag_id":"cklcaoe4j000dxjl84pznbg8t","_id":"cklcaoe4k000gxjl84i5w08y6"}],"Tag":[{"name":"c/c++","_id":"cklcaoe4f0005xjl82ndj7wcc"},{"name":"ml","_id":"cklcaoe4i0008xjl84p2z156s"},{"name":"dl","_id":"cklcaoe4j000bxjl8cdu2h5l3"},{"name":"object-detection","_id":"cklcaoe4j000dxjl84pznbg8t"}]}}